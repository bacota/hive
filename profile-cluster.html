<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Build Profile Clusters</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.48.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.48.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>


<div id='map'>
</div>
<script>


/**
 * ZCTA wise metric details
 * @type {Object}
 */
var zcta_metrics = {};

/**
 * ZCTA to GEO ID Mapping
 * @type {Object}
 */
var zcta_geoid = {};

/**
 * COUNTY to GEO ID Mapping
 * @type {Object}
 */
var county_geoid = {};

var oProfiles = {};



mapboxgl.accessToken = 'pk.eyJ1IjoiaWFzaGlzaHNpbmdoIiwiYSI6ImNqbHQ2d2JpcTA1cnEzcG9idGl2aTN5MTMifQ.yGUYoyQ4IyAfzl3E2D0ecA';

var map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/light-v9',
    center: [-99.9, 41.5],
    zoom: 3
});

// Join local JSON data with vector tile geometry
// USA unemployment rate in 2009
// Source https://data.bls.gov/timeseries/LNS14000000
var maxValue = 13;

map.on('load', function() {

    // Load custom data
    loadData(function(aProfilesGeoJSON){

        setupProfileCluster(aProfilesGeoJSON);
        
        /*
        
        // Add layer from the vector tile source with data-driven style
        map.addLayer({
            "id": "counties-join",
            "type": "fill",
            //"source": "counties",
            "source": "counties-localdata",
            //"source-layer": "states",
            //"source-layer": "us-census-vis",
            //"source-layer": "gz_2010_us_20m-aqxozo",
            
            //"source-layer": "gz_2010_us_050_00_20m-a22ia7",

            "paint": {
                //"fill-color": aExpression
                'fill-color': [
                    'interpolate',
                    ['linear'],
                    ['get', 'unemp_rate'],
                    0, '#F2F12D',
                    2, '#EED322',
                    5, '#E6B71E',
                    6, '#DA9C20',
                    8, '#CA8323',
                    15, '#B86B25'
                ],
                'fill-opacity': 0.75
            }
        }, 'waterway-label');

        */
        
        
    });


});

function setupProfileCluster(aGeoJSON) {
    
    // Add a new source from our GeoJSON data and set the
    // 'cluster' option to true. GL-JS will add the point_count property to your source data.
    map.addSource("profiles", {
        type: "geojson",
        data: aGeoJSON,
        cluster: true,
        // Max zoom to cluster points on
        clusterMaxZoom: 14,
        // Radius of each cluster when clustering points (defaults to 50)
        clusterRadius: 50
    });

    map.addLayer({
        id: "clusters",
        type: "circle",
        source: "profiles",
        filter: ["has", "point_count"],
        paint: {
            // Use step expressions (https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-step)
            // with three steps to implement three types of circles:
            //   * Blue, 20px circles when point count is less than 100
            //   * Yellow, 30px circles when point count is between 100 and 750
            //   * Pink, 40px circles when point count is greater than or equal to 750
            "circle-color": [
                "step",
                ["get", "point_count"],
                "#51bbd6",
                10,
                "#f1f075",
                75,
                "#f28cb1"
            ],
            "circle-radius": [
                "step",
                ["get", "point_count"],
                20,
                2,
                30,
                5,
                40
            ]
        }
    });

    map.addLayer({
        id: "cluster-count",
        type: "symbol",
        source: "profiles",
        filter: ["has", "point_count"],
        layout: {
            "text-field": "{point_count_abbreviated}",
            "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
            "text-size": 12
        }
    });

    map.addLayer({
        id: "unclustered-point",
        type: "circle",
        source: "profiles",
        filter: ["!", ["has", "point_count"]],
        paint: {
            "circle-color": "#11b4da",
            "circle-radius": 4,
            "circle-stroke-width": 1,
            "circle-stroke-color": "#fff"
        }
    });


}


/**
 * Add a new data source to Map
 * @param {[type]} options [description]
 */
function addSource2Map(options) {

    map.addSource(options.id, {
        "type": options.type || "geojson",
        "data": options.data
    });

}

/**
 * Add a new Layer to Map
 * @param {[type]} options [description]
 */
function addLayer2Map(options) {

    var oLayer = {
        "id": options.id,
        "type": options.type || "fill",
        "source": options.source,
        "paint": options.paint
    };

    // Is there a filter defined?
    // 
    if (options.filter) {

        oLayer = Object.assign(oLayer, {
            filter: options.filter
        });

    }

    // Is there another layer to be considered
    //
    map.addLayer(oLayer, options.beforeLayer || 'waterway-label');
    
}


// TODO - Move all data processing to a Web worker
// 
function loadData(callback) {

    var aMissingZCTA = [];

    // Load Profiles Dataset
    // 
    d3.csv("data/viz/0-Raw-Data-Sample-ORIGINAL.csv", function(d){

        oProfiles

        return d;

    }).then(function(aProfiles){

        console.log("aProfiles", aProfiles);

        var aZip = aProfiles.map(function(d){
            return getSanitizedZip(d.Zip);
        }),
        aZipUnique = _.uniq(aZip);

        console.log('aZipUnique', aZipUnique);

        

        // Load Counties TopoJSON
        // 
        // 1. Filter topologies where our profiles are situated.
        // 2. Get GeoJSON features of these topologies
        // 3. Get centroid of GeoJSON features
        // 4. Build a GeoJSON data source
        // 5. Add the data source to map with clustering
        // 6. Add a layer which uses 5.
        // 
        
        // data/scripts/json/us_counties-final-quantized-topo.json
        // data/TopoJSON/us_counties_final.json
        // 
        /*
        d3.json("data/scripts/json/us_counties-final-quantized-topo.json").then(function(oTopo){

            //console.log('oTopo', oTopo);

            // 1. Filter topologies where our profiles are situated.
            // 'us_counties_final'
            var aTopologies = getTopoFromZip(oTopo.objects['counties'].geometries, aZipUnique);

            console.log("Found topologies", aTopologies, 'aMissingZCTA' , aZipUnique);


            // 2. Get GeoJSON features of these topologies
            // 

            var aFeatureGeo = topo2Geo(aTopologies, oTopo.arcs);

            console.log('Geo Features', aFeatureGeo);

            // 3. Get centroid of GeoJSON features
            // 
            var aFeatureCentroids = getGeoCentroid(aFeatureGeo);

            console.log('Centroid Geo Features', aFeatureCentroids);

            // 4. Build a GeoJSON data source
            // 
            var aGeoJSON = getFeatureCollectionFromFeatures(aFeatureCentroids);

            console.log('GeoJSON', aGeoJSON);

            // 5. Add the data source to map with clustering
            // 
            callback(turf.toWgs84(aGeoJSON));
            
        });
        */
       
        // Work with GeoJSON
        // 
        

        d3.json("data/GeoJSON/counties/cb_2017_us_zcta510_500k_1per.json").then(function(oGeoJSON){

            //console.log('oTopo', oTopo);

            // 1. Filter features where our profiles are situated.
            // 
            var aFeatureGeo = getFeaturesFromZip(oGeoJSON.features, aZipUnique);

            console.log("Found features", aFeatureGeo, 'aMissingZCTA' , aZipUnique);

            // 3. Get centroid of GeoJSON features
            // 
            var aFeatureCentroids = getGeoCentroid(aFeatureGeo);

            console.log('Centroid Geo Features', aFeatureCentroids);

            // 4. Build a GeoJSON data source
            // 
            var aGeoJSON = getFeatureCollectionFromFeatures(aFeatureCentroids);

            console.log('GeoJSON', aGeoJSON);

            // 5. Add the data source to map with clustering
            // 
            callback(aGeoJSON);
            
        });

        /*
        d3.csv("data/CSV/uszipsv1.2-zip-to-zcta-reduced.csv").then(function(oTopo){

            //console.log('oTopo', oTopo);
            
        });*/
        

    });

    /**
     * Sanitize a USPS ZIP Code
     *
     * 1. Shorten it: 66217-9570 should become 66217
     * 2. Complete it: 9570 should become 09570
     */
    function getSanitizedZip(sZip) {
        if (!sZip) {
            return null;
        }
        // 1.
        if (sZip.length != 5) {
            return _complete(sZip);
        }

        return sZip;

        // 2.
        function _complete(sZipShort) {
            if (sZipShort.length < 5) {
                var fill = d3.range(5 - sZipShort.length),
                aFiller = [];
                fill.forEach(function(){
                    aFiller.push(0);
                });
                return aFiller.join('') + sZipShort;
            }

            return sZipShort.slice(0, 5);
        }
    }

    /**
     * Get Topologies for Zip codes
     * @param  {TopoJSON} aTopologies 
     * @param  {array}    aZip        Unique Zip code
     * @return {array}                Topologies
     */
    function getTopoFromZip(aGeometry, aZip) {

        return aGeometry.filter(function(g){
            var index = aZip.indexOf(g.properties.ZCTA);
            if (index > -1) {
                aZip.splice(index, 1);
                return true;
            }
            return false;
        });
    }

    function getFeaturesFromZip(aFeatures, aZip){
        return aFeatures.filter(function(g){
            // TODO - work with processed GeoJSON with metrics
            var index = aZip.indexOf(g.properties.ZCTA5CE10);
            if (index > -1) {
                aZip.splice(index, 1);
                return true;
            }
            return false;
        });
    }

    /**
     * Get a ZCTA for a Zip
     * @param  {array} aZipUnique Zip
     * @return {array}            ZCTA
     */
    function getZCTAFromZip(aZipUnique) {
        // TODO
        // 1. Build a map from file uszipsv1.2-zip-to-zcta.csv
        // 2. Use results from this mapping to find ZCTA of a Zip
    }


    /**
     * Convert topolgies to GeoJSON features
     * @param  {array} aTopologies 
     * @return {array} GeoJSON Features 
     */
    function topo2Geo(aTopologies, aTopoArcs) {

        function simpleTopology(object) {
          return {
            type: "Topology",
            transform: {scale: [1, 1], translate: [0, 0]},
            objects: {foo: object},
            arcs: aTopoArcs
          };
        }

        var aGeo = [];

        aTopologies.map(function(t){

            var oTopoGeometry = simpleTopology(t);

            aGeo.push(topojson.feature(oTopoGeometry, oTopoGeometry.objects.foo));

        });

        return aGeo;
        
    }

    /**
     * Get Centroid of a GeoJSON feature
     * @param  {array} aFeatures
     * @return {array} aFeature with type Point
     */
    function getGeoCentroid(aFeatures) {
        
        return aFeatures.map(function(f, i){
            // Coordinates must have numbers
            // 
            var centroid;
            try{
                centroid = turf.centroid(f, f.properties);
            }catch(e){
                console.log('[Error turf.centroid]', e.message);
            }
            return centroid;
        }).filter(function(c){
            return !!c;
        });
    }

    /**
     * Get a FeatureCollection from a set of Features | GeoJSON
     * @param  {Array} aFeatures Features
     * @return {JSON}           FeatureCollection
     */
    function getFeatureCollectionFromFeatures(aFeatures) {
        return turf.featureCollection(aFeatures);
    }

    /**
     * Package an array of GeoJSON features into a FeatureCollection
     * @param  {array}  aFeatures
     * @return {JSON}
     */
    function packageFeatures2Collection(aFeatures) {
        
    }
    


}


</script>

</body>
</html>