<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Build Profile Clusters</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.48.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.48.0/mapbox-gl.css' rel='stylesheet' />

    <link rel="stylesheet" type="text/css" href="assets/css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chosen/1.8.7/chosen.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.7.0/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5/turf.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chosen/1.8.7/chosen.jquery.min.js"></script>

    <!-- Custom Scripts -->
    <script src="assets/js/map.js"></script>
    
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:0; bottom:0; width:100%; }
    </style>
</head>
<body>


<div id='map'></div>

<div class="filter-panel">

    <div class="filter-panel-header">

        <div>42 Records</div>
        <div>5 Bookmarks</div>
        
    </div>

    <div class="filter-panel-body">

        <div class="filters">

            <!-- Display -->
            <div id="filter_display"></div>
            
        </div>

        <h2>Adoption Score</h2>
        <div class="filters">

            <!-- Hardware -->
            <div id="filter_hardware"></div>
            
            <!-- Software -->
            <div id="filter_software"></div>

        </div>

        <h2>Demographics</h2>
        <div class="filters">

            <!-- Gender -->
            <div id="filter_gender"></div>

            <!-- Age -->
            <div id="filter_age"></div>

            <!-- Employment Status -->
            <div id="filter_employment"></div>

            <!-- Own / Rent -->
            <div id="filter_ownrent"></div>

            <!-- Decision Maker -->
            <div id="filter_decision"></div>

            <!-- Annual HHI -->
            <div id="filter_hhi"></div>

            <!-- Children in Home -->
            <div id="filter_children"></div>
            
        </div>

        <h2>Zip Code Association</h2>
        <div class="filters">
            TODO
            <div id="filter_zip_den"></div>

            <div id="filter_zip_unemp"></div>
        </div>

        <h2>Usage</h2>
        <div class="filters">

            <!-- Device Adoption Score -->
            <div id="filter_adop_device"></div>

            <!-- Software Adoption Score -->
            <div id="filter_adop_software"></div>

            <!-- Device Usage -->
            <div id="filter_device_usage"></div>

            <!-- Purchase Habits -->
            <div id="filter_habit_purchase"></div>

            <!-- Annual Support Requests -->
            <div id="filter_annual_support"></div>

            <!-- Purchased Protection -->
            <div id="filter_purchased_protection"></div>

            <!-- Perception of Protection -->
            <div id="filter_perception_protection"></div>
            
        </div>

        <h2>Consent</h2>
        <div class="filters">

            <!-- Video Diaries -->
            <div id="filter_video_diaries"></div>
            
        </div>
        
    </div>

</div>

<script>


/**
 * ZCTA wise metric details
 * @type {Object}
 */
var zcta_metrics = {};

/**
 * ZCTA to GEO ID Mapping
 * @type {Object}
 */
var zcta_geoid = {};

/**
 * COUNTY to GEO ID Mapping
 * @type {Object}
 */
var county_geoid = {};

var oProfiles = {};

/*

mapboxgl.accessToken = 'pk.eyJ1IjoiaWFzaGlzaHNpbmdoIiwiYSI6ImNqbHQ2d2JpcTA1cnEzcG9idGl2aTN5MTMifQ.yGUYoyQ4IyAfzl3E2D0ecA';

var map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/light-v9',
    center: [-99.9, 41.5],
    zoom: 3
});

// Join local JSON data with vector tile geometry
// USA unemployment rate in 2009
// Source https://data.bls.gov/timeseries/LNS14000000
var maxValue = 13;

map.on('load', function() {

    // Load custom data
    loadData(function(aProfilesGeoJSON){

        setupProfileCluster(aProfilesGeoJSON);
        
    });


});

*/

function setupProfileCluster(aGeoJSON) {
    
    // Add a new source from our GeoJSON data and set the
    // 'cluster' option to true. GL-JS will add the point_count property to your source data.
    map.addSource("profiles", {
        type: "geojson",
        data: aGeoJSON,
        cluster: true,
        // Max zoom to cluster points on
        clusterMaxZoom: 14,
        // Radius of each cluster when clustering points (defaults to 50)
        clusterRadius: 50
    });

    map.addLayer({
        id: "clusters",
        type: "circle",
        source: "profiles",
        filter: ["has", "point_count"],
        paint: {
            // Use step expressions (https://www.mapbox.com/mapbox-gl-js/style-spec/#expressions-step)
            // with three steps to implement three types of circles:
            //   * Blue, 20px circles when point count is less than 100
            //   * Yellow, 30px circles when point count is between 100 and 750
            //   * Pink, 40px circles when point count is greater than or equal to 750
            "circle-color": [
                "step",
                ["get", "point_count"],
                "#51bbd6",
                10,
                "#f1f075",
                75,
                "#f28cb1"
            ],
            "circle-radius": [
                "step",
                ["get", "point_count"],
                20,
                2,
                30,
                5,
                40
            ]
        }
    });

    map.addLayer({
        id: "cluster-count",
        type: "symbol",
        source: "profiles",
        filter: ["has", "point_count"],
        layout: {
            "text-field": "{point_count_abbreviated}",
            "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
            "text-size": 12
        }
    });

    map.addLayer({
        id: "unclustered-point",
        type: "circle",
        source: "profiles",
        filter: ["!", ["has", "point_count"]],
        paint: {
            "circle-color": "#11b4da",
            "circle-radius": 4,
            "circle-stroke-width": 1,
            "circle-stroke-color": "#fff"
        }
    });


}


/**
 * Add a new data source to Map
 * @param {[type]} options [description]
 */
function addSource2Map(options) {

    map.addSource(options.id, {
        "type": options.type || "geojson",
        "data": options.data
    });

}

/**
 * Add a new Layer to Map
 * @param {[type]} options [description]
 */
function addLayer2Map(options) {

    var oLayer = {
        "id": options.id,
        "type": options.type || "fill",
        "source": options.source,
        "paint": options.paint
    };

    // Is there a filter defined?
    // 
    if (options.filter) {

        oLayer = Object.assign(oLayer, {
            filter: options.filter
        });

    }

    // Is there another layer to be considered
    //
    map.addLayer(oLayer, options.beforeLayer || 'waterway-label');
    
}


// TODO - Move all data processing to a Web worker
// 
function loadData(callback) {

    var aMissingZCTA = [];

    // Load Profiles Dataset
    // 
    d3.csv("data/viz/0-Raw-Data-Sample-ORIGINAL.csv", function(d){

        d._zip = getSanitizedZip(d.Zip);

        return d;

    }).then(function(aProfiles){

        console.log("aProfiles", aProfiles);

        var aZip = aProfiles.map(function(d){
            return d._zip;
        }),
        aZipUnique = _.uniq(aZip);

        console.log('aZipUnique', aZipUnique);

        

        // Load Counties TopoJSON
        // 
        // 1. Filter topologies where our profiles are situated.
        // 2. Get GeoJSON features of these topologies
        // 3. Get centroid of GeoJSON features
        // 4. Build a Map of properties.zcta to feature
        // 5. Add a Point feature for every profile
        // 6. Build a GeoJSON data source
        
        // 
        
        // data/scripts/json/us_counties-final-quantized-topo.json
        // data/TopoJSON/us_counties_final.json
        // data/TopoJSON/mapshaper/us_counties_final-topo-webmercator.json
        // data/TopoJSON/mapshaper/us_counties_final-topo.json
        // 
        /*
        d3.json("data/TopoJSON/geojson-io/us_counties_final-topo.topojson").then(function(oTopo){

            //console.log('oTopo', oTopo);

            // 1. Filter topologies where our profiles are situated.
            // 'us_counties_final'
            var aTopologies = getTopoFromZip(oTopo.objects['collection'].geometries, aZipUnique);

            console.log("Found topologies", aTopologies, 'aMissingZCTA' , aZipUnique);


            // 2. Get GeoJSON features of these topologies
            // 

            var aFeatureGeo = topo2Geo(aTopologies, oTopo.arcs);

            console.log('Geo Features', aFeatureGeo);

            // 3. Get centroid of GeoJSON features
            // 
            var aFeatureCentroids = getGeoCentroid(aFeatureGeo);

            console.log('Centroid Geo Features', aFeatureCentroids);

            // 4. Build a GeoJSON data source
            // 
            var aGeoJSON = getFeatureCollectionFromFeatures(aFeatureCentroids);

            console.log('GeoJSON', aGeoJSON);

            // 5. Add the data source to map with clustering
            // 
            callback(turf.toWgs84(aGeoJSON));
            
        });
        */
    
       
        // Work with GeoJSON
        // 
        // data/TopoJSON/mapshaper/us_counties_final-topo.json
        // data/GeoJSON/counties/cb_2017_us_zcta510_500k_1per.json
        
        d3.json("data/TopoJSON/mapshaper/us_counties_final-geo.json").then(function(oGeoJSON){

            //console.log('oTopo', oTopo);

            // 1. Filter features where our profiles are situated.
            // 
            var aFeatureGeo = getFeaturesFromZip(oGeoJSON.features, aZipUnique);

            console.log("Found features", aFeatureGeo, 'aMissingZCTA' , aZipUnique);

            // 3. Get centroid of GeoJSON features
            // 
            var aFeatureCentroids = getGeoCentroid(aFeatureGeo);

            console.log('Centroid Geo Features', aFeatureCentroids);

            // 4. Build a Map of properties.zcta to feature
            // 
            var oZCTAFeature = d3.map(aFeatureCentroids, function(f){
                return f.properties.ZCTA;
            });

            // 5. Add a Point feature for every profile
            // 
            var aProfileCentroids = aProfiles.map(function(p){
                // TODO
                // Find the ZCTA via lookup
                // 
                return oZCTAFeature.get(p._zip);
            }).filter(function(p){
                return !!p;
            });

            // 6. Build a GeoJSON data source
            // 
            var aGeoJSON = getFeatureCollectionFromFeatures(aProfileCentroids);

            console.log('GeoJSON', aGeoJSON);

            // 5. Add the data source to map with clustering
            // 
            callback(aGeoJSON);
            
        });


        /*
        d3.csv("data/CSV/uszipsv1.2-zip-to-zcta-reduced.csv").then(function(oTopo){

            //console.log('oTopo', oTopo);
            
        });*/
        

    });

    /**
     * Sanitize a USPS ZIP Code
     *
     * 1. Shorten it: 66217-9570 should become 66217
     * 2. Complete it: 9570 should become 09570
     */
    function getSanitizedZip(sZip) {
        if (!sZip) {
            return null;
        }
        // 1.
        if (sZip.length != 5) {
            return _complete(sZip);
        }

        return sZip;

        // 2.
        function _complete(sZipShort) {
            if (sZipShort.length < 5) {
                var fill = d3.range(5 - sZipShort.length),
                aFiller = [];
                fill.forEach(function(){
                    aFiller.push(0);
                });
                return aFiller.join('') + sZipShort;
            }

            return sZipShort.slice(0, 5);
        }
    }

    /**
     * Get Topologies for Zip codes
     * @param  {TopoJSON} aTopologies 
     * @param  {array}    aZip        Unique Zip code
     * @return {array}                Topologies
     */
    function getTopoFromZip(aGeometry, aZip) {

        return aGeometry.filter(function(g){
            var index = aZip.indexOf(g.properties.ZCTA);
            if (index > -1) {
                aZip.splice(index, 1);
                return true;
            }
            return false;
        });
    }

    function getFeaturesFromZip(aFeatures, aZip){
        return aFeatures.filter(function(g){
            // TODO - work with processed GeoJSON with metrics
            // ZCTA5CE10
            var index = aZip.indexOf(g.properties.ZCTA);
            if (index > -1) {
                aZip.splice(index, 1);
                return true;
            }
            return false;
        });
    }

    /**
     * Get a ZCTA for a Zip
     * @param  {array} aZipUnique Zip
     * @return {array}            ZCTA
     */
    function getZCTAFromZip(aZipUnique) {
        // TODO
        // 1. Build a map from file uszipsv1.2-zip-to-zcta.csv
        // 2. Use results from this mapping to find ZCTA of a Zip
    }


    /**
     * Convert topolgies to GeoJSON features
     * @param  {array} aTopologies 
     * @return {array} GeoJSON Features 
     */
    function topo2Geo(aTopologies, aTopoArcs) {

        function simpleTopology(object) {
          return {
            type: "Topology",
            transform: {scale: [1, 1], translate: [0, 0]},
            objects: {foo: object},
            arcs: aTopoArcs
          };
        }

        var aGeo = [];

        aTopologies.map(function(t){

            var oTopoGeometry = simpleTopology(t);

            aGeo.push(topojson.feature(oTopoGeometry, oTopoGeometry.objects.foo));

        });

        return aGeo;
        
    }

    /**
     * Get Centroid of a GeoJSON feature
     * @param  {array} aFeatures
     * @return {array} aFeature with type Point
     */
    function getGeoCentroid(aFeatures) {
        
        return aFeatures.map(function(f, i){
            // Coordinates must have numbers
            // 
            var centroid;
            try{
                centroid = turf.centroid(f, f.properties);
            }catch(e){
                console.log('[Error turf.centroid]', e.message);
            }
            return centroid;
        }).filter(function(c){
            return !!c;
        });
    }

    /**
     * Get a FeatureCollection from a set of Features | GeoJSON
     * @param  {Array} aFeatures Features
     * @return {JSON}           FeatureCollection
     */
    function getFeatureCollectionFromFeatures(aFeatures) {
        return turf.featureCollection(aFeatures);
    }

    /**
     * Package an array of GeoJSON features into a FeatureCollection
     * @param  {array}  aFeatures
     * @return {JSON}
     */
    function packageFeatures2Collection(aFeatures) {
        
    }
    


}


</script>

<script src="assets/js/util.js"></script>
<script src="assets/js/datamodel.js"></script>
<script src="assets/js/filter.js"></script>
<script src="assets/js/popup.js"></script>
<script src="assets/js/aux.js"></script>


</body>
</html>